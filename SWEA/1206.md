# 1206

- 문제

  강변에 빌딩들이 옆으로 빽빽하게 밀집한 지역이 있다.

  이곳에서는 빌딩들이 너무 좌우로 밀집하여, 강에 대한 조망은 모든 세대에서 좋지만 왼쪽 또는 오른쪽 창문을 열었을 때 바로 앞에 옆 건물이 보이는 경우가 허다하였다.

  그래서 이 지역에서는 왼쪽과 오른쪽으로 창문을 열었을 때, 양쪽 모두 거리 2 이상의 공간이 확보될 때 조망권이 확보된다고 말한다.

  빌딩들에 대한 정보가 주어질 때, 조망권이 확보된 세대의 수를 반환하는 프로그램을 작성하시오.

- 입력

  입력 파일의 첫 번째 줄에는 테스트케이스의 길이가 주어진다. 그 바로 다음 줄에 테스트 케이스가 주어진다.

  총 10개의 테스트케이스가 주어진다.

- 출력

  \#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스의 조망권이 확보된 세대의 수를 출력한다.

```python
for case in range(1, 11):
    num_of_buildings = int(input())
    buildings_list = list(map(int, input().split())) # 들어오는 리스트를 쪼갠다.
    total_ans = 0 # 한 케이스에서의 답을 초기화한다.
    # 빌딩들의 리스트를 순환하되, 맨 처음과 마지막의 아무것도 없는 두 부분을 제외하고 순환한다.
    for i in range(2, len(buildings_list) - 2):
        five_list = sorted(buildings_list[i - 2 : i + 3 : 1]) # 순환중인 건물의 뒤 2개, 앞 2개를 비교
        tallest_in_five = max(buildings_list[i - 2 : i + 3]) # 최댓값을 뽑은 후, 만약 최대값이 본 건물이라면
        if buildings_list[i] == tallest_in_five: # 두번째로 큰 건물의 높이를 빼 줘 더해준다.
            total_ans += buildings_list[i] - five_list[-2]

    print(f"#{case} {total_ans}")

```

- 해설

  1) 리스트를 순환하며 앞 뒤 5개 중 가장 높은 아파트가 아파트 i인 경우, 두 번째 높은 아파트의 높이를 빼 준다. 높이가 같은 아파트가 존재할 경우에는 어차피 + 0이 되기 때문에 고려하지 않아도 된다.

  2) .sort()는 None을 반환한다... 즉 five_list에 할당하여 쓰려면 sorted()함수를 썼어야 했다. 틀리진 않았으나 시간을 잡아먹었다.